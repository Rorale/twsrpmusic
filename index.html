<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TWS RP MP3 Uploader</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script> 
    <style>
        /* Dark Theme Palette */
        :root {
            --color-bg-main: #1f2937;
            --color-bg-card: #374151;
            --color-text: #f3f4f6;
            --color-input-bg: #4b5563;
            --color-primary: #3b82f6; 
            --color-primary-hover: #2563eb;
            --color-secondary: #10b981;
            --color-danger: #ef4444;
        }

        body { 
            font-family: 'Inter', sans-serif; 
            background-color: var(--color-bg-main); 
            color: var(--color-text);
            min-height: 100vh;
        } 

        .card {
            background-color: var(--color-bg-card);
            border-radius: 0.75rem; 
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }

        .btn-primary {
            background-color: var(--color-primary);
            transition: background-color 0.2s;
        }
        .btn-primary:hover:not(:disabled) {
            background-color: var(--color-primary-hover);
        }
        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .tab-button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem 0.5rem 0 0;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .tab-button.active {
            background-color: var(--color-bg-card);
            color: var(--color-primary);
            font-weight: 600;
        }
        .tab-button:not(.active):hover {
            background-color: #4b5563;
        }
        /* Style for the confirmation modal */
        #customConfirmModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none; /* Initially hidden */
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        #customConfirmModal.show {
            display: flex;
        }
        .modal-content {
            background-color: var(--color-bg-card);
            padding: 2rem;
            border-radius: 0.75rem;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body class="p-4 sm:p-8 flex justify-center items-start">

    <!-- 1. ACCESS GATE (Puerta de Acceso con Contraseña) -->
    <div id="accessGate" class="fixed inset-0 bg-gray-900 bg-opacity-95 z-50 flex items-center justify-center">
        <div class="card p-8 w-full max-w-sm text-center">
            <h2 class="text-3xl font-bold mb-4 text-white">Access Required</h2>
            <p class="text-gray-400 mb-6">Please enter the daily access key to proceed.</p>
            
            <input type="password" id="accessPassword" placeholder="Enter password..." 
                   class="w-full p-3 mb-4 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:ring-blue-500 focus:border-blue-500 border-none">
            
            <button id="accessButton" class="w-full btn-primary p-3 rounded-lg text-white font-semibold">
                Enter
            </button>
            <p id="accessMessage" class="text-sm mt-4 text-red-400 hidden">Incorrect or missing key.</p>
        </div>
    </div>

    <!-- 2. MAIN APPLICATION CONTAINER -->
    <div id="appContainer" class="w-full max-w-5xl space-y-8 hidden">
        <header class="text-center">
            <!-- Título con colores específicos para TWS, ahora unidos y sin espacios -->
            <h1 class="text-4xl sm:text-5xl font-extrabold mb-2">
                <span class="text-blue-500">T</span><span class="text-yellow-400">W</span><span class="text-red-500">S</span>
                <span class="text-white"> Music Host Site</span>
            </h1>
            <!-- Descripción con texto actualizado y tamaño de fuente reducido a text-base -->
            <p class="text-base text-gray-400">A place to upload unique music dedicated for your roleplays.<br>The max. file size is 40 MB.</p>
        </header>

        <!-- Navigation Tabs -->
        <div class="flex border-b border-gray-600">
            <!-- Pestaña renombrada a solo "Home" -->
            <button class="tab-button active" data-tab="upload">
                <i data-lucide="home" class="w-4 h-4 inline mr-2"></i> Home
            </button>
            <button class="tab-button" data-tab="list">
                <i data-lucide="list" class="w-4 h-4 inline mr-2"></i> Uploaded Music Links
            </button>
        </div>

        <!-- Authentication/Status Message (Oculto en estado normal/éxito) -->
        <div id="loginStatusMessage" class="text-center text-sm text-yellow-400 py-2 rounded-md font-medium hidden">
            Initializing Firebase authentication...
        </div>

        <!-- Guía de Reglas de Storage (Oculto por defecto) -->
        <div id="storageRuleGuidance" class="bg-red-900 border border-red-700 p-4 rounded-lg hidden">
            <h3 class="text-xl font-bold text-red-300 mb-2 flex items-center">
                <i data-lucide="shield-alert" class="w-5 h-5 mr-2"></i> 
                Acción Requerida: Reglas de Firebase Storage
            </h3>
            <p class="text-gray-200 mb-3">Las reglas de Firebase Storage actuales están denegando el acceso a esta ruta. Configure la siguiente regla en la sección Storage de su Firebase Console:</p>
            <div class="bg-red-800 p-3 rounded-lg font-mono text-sm overflow-x-auto text-yellow-300">
                <pre><code>match /b/{bucket}/o/artifacts/{appId}/users/{userId}/{allPaths=**} {
    allow read, write: if request.auth != null && request.auth.uid == userId;
}</code></pre>
            </div>
            <p id="storagePathInError" class="text-xs mt-2 text-red-300"></p>
        </div>

        <!-- TAB CONTENT -->
        <div id="tabContent" class="card p-6 sm:p-8 min-h-[500px]">
            
            <!-- UPLOAD TAB (Initial View) -->
            <div id="tab-upload" class="tab-pane">
                <h2 class="text-2xl font-semibold mb-6">Upload your MP3s here</h2>
                
                <div class="space-y-6">
                    <!-- Custom Name Input -->
                    <div>
                        <label for="customNameInput" class="block text-sm font-medium text-gray-300 mb-2">Custom Name (Link Suffix)</label>
                        <input type="text" id="customNameInput" placeholder="my-awesome-song" 
                               class="w-full p-3 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:ring-blue-500 focus:border-blue-500 border-none">
                        <p class="text-xs text-gray-400 mt-1">Avoid a long name. This will be the name in the public URL. E.g., `https://.../roleplay-music/my-awesome-song`</p>
                    </div>

                    <!-- File Selection Display with Frame -->
                    <div id="fileSelectionFrame" class="border-2 border-dashed border-gray-600 p-6 rounded-lg text-center transition duration-150 cursor-pointer">
                        <i data-lucide="file-audio" class="w-8 h-8 mx-auto mb-2 text-gray-400"></i>
                        <p id="selectedFileNameDisplay" class="text-gray-400">No file selected. Click to select a file.</p>
                    </div>

                    <!-- Hidden File Input -->
                    <input type="file" id="fileInput" accept="audio/mp3,audio/mpeg" class="hidden" disabled>
                    
                    <!-- Single Action Button (Ahora dice siempre "Upload" en estado listo) -->
                    <button id="uploadButton" class="btn-primary w-full p-3 rounded-lg text-white font-semibold flex items-center justify-center" disabled>
                        <i data-lucide="upload" class="w-5 h-5 mr-2"></i>
                        Upload
                    </button>
                </div>

                <!-- Upload Status / Alert Message Container -->
                <div id="uploadStatusContainer" class="mt-8 p-4 bg-gray-700 rounded-lg hidden">
                    <p id="uploadFileName" class="text-sm mb-2 font-medium text-gray-200"></p>
                    <div class="w-full bg-gray-600 rounded-full h-2.5">
                        <div id="uploadProgressBar" class="bg-blue-500 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
                    </div>
                    <p id="uploadStatusText" class="text-xs text-gray-400 mt-2"></p>
                </div>
            </div>

            <!-- LIST TAB (Initially Hidden) -->
            <div id="tab-list" class="tab-pane hidden">
                <h2 class="text-2xl font-semibold mb-6">Available Music Links</h2>
                
                <!-- Controls: Search and Filters -->
                <div class="flex flex-col md:flex-row gap-4 mb-6">
                    <div class="relative flex-grow">
                        <input type="text" id="searchInput" placeholder="Search song by name (e.g., 1m)" 
                               class="w-full p-3 pl-10 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:ring-blue-500 focus:border-blue-500 border-none">
                        <i data-lucide="search" class="w-4 h-4 text-gray-400 absolute left-3 top-1/2 transform -translate-y-1/2"></i>
                    </div>
                    
                    <select id="sortFilter" 
                            class="p-3 rounded-lg bg-gray-700 text-white focus:ring-blue-500 focus:border-blue-500 border-none appearance-none">
                        <option value="newest">Newest to Oldest</option>
                        <option value="oldest">Oldest to Newest</option>
                        <option value="alpha">Alphabetical</option>
                    </select>
                </div>

                <!-- Song List -->
                <div id="songList" class="space-y-3">
                    <p class="text-gray-400">Loading songs or no songs found.</p>
                    <!-- Songs will be injected here -->
                </div>

                <!-- Pagination Controls -->
                <div id="pagination" class="flex justify-center items-center mt-6 space-x-2">
                    <button id="prevPageBtn" class="p-2 rounded-full bg-gray-600 text-white disabled:opacity-50" disabled>
                        <i data-lucide="chevron-left" class="w-5 h-5"></i>
                    </button>
                    <span id="pageInfo" class="text-gray-400 text-sm">Page 1</span>
                    <button id="nextPageBtn" class="p-2 rounded-full bg-gray-600 text-white disabled:opacity-50" disabled>
                        <i data-lucide="chevron-right" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>

        </div> <!-- End of tabContent -->
    </div> <!-- End of appContainer -->

    <!-- CUSTOM CONFIRMATION MODAL -->
    <div id="customConfirmModal" class="show">
        <div class="modal-content text-center">
            <h3 id="confirmTitle" class="text-xl font-bold mb-4">Confirm Deletion</h3>
            <p id="confirmMessage" class="mb-6 text-gray-300">Are you sure you want to proceed?</p>
            <div class="flex justify-center space-x-4">
                <button id="confirmCancelBtn" class="py-2 px-4 rounded-lg bg-gray-500 hover:bg-gray-400 text-white font-semibold transition">
                    Cancel
                </button>
                <button id="confirmOkBtn" class="py-2 px-4 rounded-lg bg-red-600 hover:bg-red-700 text-white font-semibold transition">
                    Delete
                </button>
            </div>
        </div>
    </div>
    <script>
        // Ocultar el modal al cargar (el CSS lo pone en display: none, pero este script asegura)
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('customConfirmModal').classList.remove('show');
        });
    </script>

    <script type="module">
        // Importaciones de Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, onSnapshot, collection, query, addDoc, orderBy, where, limit, startAfter, getDocs, doc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytesResumable, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

        // --- CONSTANTES GLOBALES ---
        const ACCESS_KEY = 'jawoHL_66';
        const ACCESS_DURATION_MS = 3 * 24 * 60 * 60 * 1000; // 3 days
        const PUBLIC_URL_BASE = 'https://twsrpmusic.blob.core.windows.net/roleplay-music/'; // URL de simulación
        const SONGS_PER_PAGE = 10;
        
        // --- VARIABLES DE ESTADO ---
        let app;
        let db;
        let auth;
        let storage;
        let userId = null; // Global user ID (for Firestore path)
        let currentPage = 1; // Current pagination page
        let lastVisible = null; // Last document from the previous page for pagination
        let firstVisible = null; // First document of the current page (for reverse pagination)
        let songsUnsubscribe = null; // Listener de Firestore
        
        // --- DOM Elements ---
        const accessGate = document.getElementById('accessGate');
        const accessPassword = document.getElementById('accessPassword');
        const accessButton = document.getElementById('accessButton');
        const accessMessage = document.getElementById('accessMessage');
        const appContainer = document.getElementById('appContainer');

        const loginStatusMessage = document.getElementById('loginStatusMessage');
        const customNameInput = document.getElementById('customNameInput');
        const fileInput = document.getElementById('fileInput');
        const fileSelectionFrame = document.getElementById('fileSelectionFrame');
        const selectedFileNameDisplay = document.getElementById('selectedFileNameDisplay'); 
        const uploadButton = document.getElementById('uploadButton');

        const uploadStatusContainer = document.getElementById('uploadStatusContainer');
        const uploadProgressBar = document.getElementById('uploadProgressBar');
        const uploadFileName = document.getElementById('uploadFileName');
        const uploadStatusText = document.getElementById('uploadStatusText');
        const songList = document.getElementById('songList');
        const searchInput = document.getElementById('searchInput');
        const sortFilter = document.getElementById('sortFilter');
        const prevPageBtn = document.getElementById('prevPageBtn');
        const nextPageBtn = document.getElementById('nextPageBtn');
        const pageInfo = document.getElementById('pageInfo');
        
        // Modal elements
        const customConfirmModal = document.getElementById('customConfirmModal');
        const confirmTitle = document.getElementById('confirmTitle');
        const confirmMessage = document.getElementById('confirmMessage');
        const confirmOkBtn = document.getElementById('confirmOkBtn');
        const confirmCancelBtn = document.getElementById('confirmCancelBtn');

        // New Guidance Elements
        const storageRuleGuidance = document.getElementById('storageRuleGuidance');
        const storagePathInError = document.getElementById('storagePathInError');


        // --- FIREBASE PATHS ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const getPrivateCollectionRef = (collectionName) => {
            if (!userId) throw new Error("User not authenticated for private data.");
            // Log para debug
            console.log(`Firestore Path: artifacts/${appId}/users/${userId}/${collectionName}`);
            return collection(db, `artifacts/${appId}/users/${userId}/${collectionName}`);
        };

        // ---------------------------------------------------------------------
        // VI. UTILITIES (Alerts & Confirmations)
        // ---------------------------------------------------------------------
        
        /**
         * Muestra una alerta simple en el contenedor de estado.
         */
        window.alertUser = (title, message, color = 'var(--color-primary)', duration = 5000) => {
            // Detener el proceso de carga si está activo (para no interferir con la barra)
            if (title === "Success" || title === "Error" || title === "Input Error") {
                uploadProgressBar.style.width = '100%';
                uploadProgressBar.style.backgroundColor = color;
                uploadStatusContainer.classList.remove('hidden');
                uploadFileName.textContent = title;
                uploadStatusText.innerHTML = message;
                
                // Asegurar que la guía de reglas de storage se oculte si es una alerta normal
                if (storageRuleGuidance) {
                    storageRuleGuidance.classList.add('hidden');
                }

                // Ocultar después de la duración especificada
                setTimeout(() => {
                    uploadStatusContainer.classList.add('hidden');
                }, duration);
            } else {
                // Para errores fatales o mensajes que deben persistir
                uploadStatusContainer.classList.remove('hidden');
                uploadProgressBar.style.width = '100%';
                uploadProgressBar.style.backgroundColor = color;
                uploadFileName.textContent = title;
                uploadStatusText.innerHTML = message;
            }
        };

        /**
         * Muestra un modal de confirmación personalizado (reemplazo de window.confirm).
         * @param {string} title - Título del modal.
         * @param {string} message - Mensaje del modal.
         * @param {string} confirmText - Texto del botón de confirmación.
         * @returns {Promise<boolean>} Promesa que se resuelve a true (OK) o false (Cancel).
         */
        const customConfirm = (title, message, confirmText = 'Confirm') => {
            return new Promise(resolve => {
                confirmTitle.textContent = title;
                confirmMessage.textContent = message;
                confirmOkBtn.textContent = confirmText;
                customConfirmModal.classList.add('show');
                
                const handleOk = () => {
                    customConfirmModal.classList.remove('show');
                    confirmOkBtn.removeEventListener('click', handleOk);
                    confirmCancelBtn.removeEventListener('click', handleCancel);
                    resolve(true);
                };

                const handleCancel = () => {
                    customConfirmModal.classList.remove('show');
                    confirmOkBtn.removeEventListener('click', handleOk);
                    confirmCancelBtn.removeEventListener('click', handleCancel);
                    resolve(false);
                };
                
                confirmOkBtn.addEventListener('click', handleOk);
                confirmCancelBtn.addEventListener('click', handleCancel);
            });
        };
        
        // ---------------------------------------------------------------------
        // I. ACCESS CONTROL LOGIC (Lógica de Control de Acceso)
        // ---------------------------------------------------------------------
        
        const checkAccess = () => {
            const grantedUntil = localStorage.getItem('tws_access_granted');
            const now = new Date().getTime();
            return grantedUntil && now < parseInt(grantedUntil, 10);
        };

        const grantAccess = () => {
            const expiryTime = new Date().getTime() + ACCESS_DURATION_MS;
            localStorage.setItem('tws_access_granted', expiryTime.toString());
            accessGate.classList.add('hidden');
            appContainer.classList.remove('hidden');
            initApp();
        };

        const handleAccessAttempt = () => {
            if (accessPassword.value === ACCESS_KEY) {
                accessMessage.classList.add('hidden');
                grantAccess();
            } else {
                accessMessage.textContent = "Incorrect key. Please try again.";
                accessMessage.classList.remove('hidden');
                accessPassword.value = '';
            }
        };

        // ---------------------------------------------------------------------
        // II. UI NAVIGATION (Navegación de UI)
        // ---------------------------------------------------------------------

        const switchTab = (tabId) => {
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active', 'bg-gray-700');
                if (btn.dataset.tab === tabId) {
                    btn.classList.add('active');
                }
            });
            document.querySelectorAll('.tab-pane').forEach(pane => {
                pane.classList.add('hidden');
            });
            document.getElementById(`tab-${tabId}`).classList.remove('hidden');

            // If switching to the list, force loading songs
            if (tabId === 'list' && userId) {
                currentPage = 1;
                lastVisible = null;
                setupSongsListener();
            }
        };

        document.querySelectorAll('.tab-button').forEach(btn => {
            btn.addEventListener('click', () => {
                switchTab(btn.dataset.tab);
            });
        });

        // ---------------------------------------------------------------------
        // III. UPLOAD LOGIC (Lógica de Subida)
        // ---------------------------------------------------------------------

        /**
         * Maneja la carga de archivos de audio a Firebase Storage y guarda metadatos.
         */
        const uploadSong = async (file, customName) => {
            // Verificación de autenticación. El botón de subida está deshabilitado si la autenticación falla.
            if (!auth.currentUser || !userId) {
                window.alertUser("Error", "Authentication required. Please wait for initialization.", 'var(--color-danger)');
                return;
            }
            const currentUserId = userId; // Usamos el UID global ya establecido por onAuthStateChanged

            // Validar Custom Name
            if (!customName || customName.trim() === '') {
                window.alertUser("Input Error", "Custom Name is required.", 'var(--color-danger)');
                return;
            }
            // Sanitize custom name: only letters, numbers, and hyphens
            const sanitizedCustomName = customName.trim().replace(/[^a-zA-Z0-9-]/g, '-');

            // 1. Configuración de la interfaz de carga
            uploadStatusContainer.classList.remove('hidden');
            uploadFileName.textContent = `File: ${file.name}`;
            uploadProgressBar.style.width = '0%';
            uploadProgressBar.style.backgroundColor = 'var(--color-primary)';
            uploadStatusText.textContent = 'Starting upload...';
            uploadButton.disabled = true;
            fileSelectionFrame.classList.remove('border-blue-500');
            storageRuleGuidance.classList.add('hidden'); // Ocultar guía al iniciar

            // Path de almacenamiento en Firebase Storage (USANDO LA ESTRUCTURA COMPLETA DE ARTIFACTS Y SIN TIMESTAMP)
            // Se usa el formato: artifacts/{appId}/users/{userId}/tws-music/{customName}
            const storagePath = `artifacts/${appId}/users/${currentUserId}/tws-music/${sanitizedCustomName}`;
            
            // LOG DE DEBUG PARA VERIFICAR LA RUTA
            console.log(`[STORAGE DEBUG] Attempting to upload for User ID: ${currentUserId} to path: ${storagePath}`);

            const storageRef = ref(storage, storagePath);
            const uploadTask = uploadBytesResumable(storageRef, file);

            try {
                // 2. Monitoreo de Progreso
                uploadTask.on('state_changed', 
                    (snapshot) => {
                        const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                        uploadProgressBar.style.width = `${progress.toFixed(0)}%`;
                        uploadStatusText.textContent = `Uploading: ${progress.toFixed(0)}%`;
                    },
                    (error) => {
                        // 3. Manejo de Errores de Carga
                        console.error("Upload Error:", error);
                        
                        const isPermissionError = error.code === 'storage/unauthorized';

                        if (isPermissionError) {
                            // MOSTRAR GUÍA DE REGLAS DE STORAGE
                            if (storageRuleGuidance && storagePathInError) {
                                storageRuleGuidance.classList.remove('hidden');
                                storagePathInError.textContent = `Ruta denegada: ${storagePath}`;
                            }

                            // Mensaje de error de permiso simplificado
                            uploadStatusText.innerHTML = `
                                <span class="font-bold text-red-300">ERROR: Permiso de Almacenamiento Denegado.</span> 
                                <br>
                                <span class="text-white">Por favor, revise la sección "Acción Requerida: Reglas de Firebase Storage" arriba.</span>
                            `;
                            uploadButton.innerHTML = `<i data-lucide="lock" class="w-5 h-5 mr-2"></i> ERROR DE PERMISO`;
                            uploadProgressBar.style.backgroundColor = 'var(--color-danger)'; // Rojo para el error

                        } else {
                            uploadStatusText.textContent = `ERROR: La carga falló (${error.message}).`;
                            uploadButton.innerHTML = `<i data-lucide="alert-triangle" class="w-5 h-5 mr-2"></i> Error de Carga`; 
                            uploadProgressBar.style.backgroundColor = 'var(--color-danger)'; // Rojo para el error
                        }

                        uploadButton.disabled = false;
                        lucide.createIcons();
                    },
                    async () => {
                        // 4. Carga Completa: Obtener URL y Guardar en Firestore
                        uploadStatusText.textContent = 'Upload complete. Saving metadata...';
                        const firebaseURL = await getDownloadURL(uploadTask.snapshot.ref);

                        // Simular la URL pública deseada
                        const publicLink = PUBLIC_URL_BASE + sanitizedCustomName;

                        const songData = {
                            userId: currentUserId, // Verified ID for Firestore
                            customName: sanitizedCustomName,
                            fileName: file.name,
                            storagePath: storagePath,
                            firebaseURL: firebaseURL, // Real URL for streaming/download
                            publicLink: publicLink,   // Simulated URL for user use
                            uploadedAt: new Date().toISOString(),
                        };

                        await addDoc(getPrivateCollectionRef('tws-songs'), songData);
                        
                        // 5. Éxito Final
                        window.alertUser('Success', `Song uploaded! Link: <span class="font-semibold text-white">${publicLink}</span>`, 'var(--color-secondary)');
                        
                        // Clean UI
                        customNameInput.value = ''; 
                        fileInput.value = ''; 
                        selectedFileNameDisplay.textContent = "No file selected. Click to select a file.";
                        fileSelectionFrame.classList.remove('border-blue-500');
                        
                        // Reset button
                        uploadButton.disabled = false;
                        uploadButton.innerHTML = `<i data-lucide="upload" class="w-5 h-5 mr-2"></i> Upload`;
                        lucide.createIcons();
                    }
                );
            } catch (error) {
                // General Upload Error
                console.error("General Upload Error:", error);
                window.alertUser("FATAL ERROR", error.message, 'var(--color-danger)', 8000);
                uploadButton.disabled = false;
                uploadButton.innerHTML = `<i data-lucide="alert-triangle" class="w-5 h-5 mr-2"></i> Error - Upload`;
                lucide.createIcons();
            }
        };
        // FIN DEL PARCHE

        // ---------------------------------------------------------------------
        // IV. LISTING AND SEARCH LOGIC (Lógica de Listado, Búsqueda y Paginación)
        // ---------------------------------------------------------------------

        const deleteSong = async (songId, storagePath, customName) => {
            // Reemplazo de window.confirm por customConfirm
            const confirmed = await customConfirm(
                'Confirm Deletion', 
                `Are you sure you want to delete the song: "${customName}"? This action cannot be undone.`, 
                'Delete'
            );

            if (!confirmed) {
                return;
            }

            try {
                // 1. Delete from Firebase Storage
                const storageRef = ref(storage, storagePath);
                await deleteObject(storageRef);
                
                // 2. Delete document from Firestore
                const songDocRef = doc(getPrivateCollectionRef('tws-songs'), songId);
                await deleteDoc(songDocRef);

                window.alertUser('Success', `Song "${customName}" deleted successfully.`, 'var(--color-secondary)');
                
                // Recargar la lista
                setupSongsListener(currentPage);

            } catch (error) {
                console.error("Error deleting song:", error);
                window.alertUser('Deletion Error', `Could not delete song. Check console. (${error.message})`, 'var(--color-danger)');
            }
        };

        window.deleteSong = deleteSong; // Make deleteSong available globally

        const renderSongs = (songs) => {
            songList.innerHTML = ''; // Clear list
            
            if (songs.length === 0) {
                songList.innerHTML = '<p class="text-gray-400">No music links found. Try uploading some files!</p>';
                return;
            }

            const listHtml = songs.map(song => `
                <div class="p-4 bg-gray-700 rounded-lg flex flex-col sm:flex-row items-start sm:items-center justify-between hover:bg-gray-600 transition duration-150">
                    <div class="truncate w-full sm:w-2/3 mb-2 sm:mb-0">
                        <span class="font-medium text-lg text-white block truncate">${song.customName}</span>
                        <a href="${song.publicLink}" target="_blank" class="text-sm text-blue-400 hover:text-blue-300 truncate block">${song.publicLink}</a>
                    </div>
                    <div class="flex items-center space-x-3 text-sm mt-2 sm:mt-0">
                        <span class="text-gray-400 hidden md:inline">${new Date(song.uploadedAt).toLocaleDateString()}</span>
                        <button class="text-blue-400 hover:text-blue-300" onclick="copyToClipboard('${song.publicLink}')">
                            <i data-lucide="copy" class="w-4 h-4"></i>
                        </button>
                        <a href="${song.firebaseURL}" download class="text-green-400 hover:text-green-300">
                            <i data-lucide="download" class="w-4 h-4"></i>
                        </a>
                        <!-- Delete button, calling the global function -->
                        <button class="text-red-400 hover:text-red-300" onclick="window.deleteSong('${song.id}', '${song.storagePath}', '${song.customName.replace(/'/g, "\\'")}')">
                            <i data-lucide="trash-2" class="w-4 h-4"></i>
                        </button>
                    </div>
                </div>
            `).join('');

            songList.innerHTML = listHtml;
            lucide.createIcons();
        };

        const updatePaginationControls = (snapshotSize, hasMore) => {
            // Update page info
            pageInfo.textContent = `Page ${currentPage}`;

            // Check if there's a previous page
            prevPageBtn.disabled = currentPage === 1;

            // Check if there's a next page (based on the snapshot size vs page limit)
            nextPageBtn.disabled = !hasMore;
            
            lucide.createIcons();
        };


        /**
         * Configura el listener de Firestore para la lista de canciones con filtros y paginación.
         */
        const setupSongsListener = async (page = 1) => {
            if (songsUnsubscribe) songsUnsubscribe(); // Detener listener anterior
            if (!db || !userId) return;

            songList.innerHTML = '<p class="text-gray-400">Loading songs...</p>';

            const searchTerm = searchInput.value.toLowerCase().trim();
            const sortBy = sortFilter.value;
            let orderField = 'uploadedAt';
            let direction = 'desc';

            if (sortBy === 'alpha') {
                orderField = 'customName';
                direction = 'asc';
            } else if (sortBy === 'oldest') {
                orderField = 'uploadedAt';
                direction = 'asc';
            }
            
            // Build the base query
            let songsQuery = query(
                getPrivateCollectionRef('tws-songs'),
                orderBy(orderField, direction),
                limit(SONGS_PER_PAGE + 1) // Fetch one extra document to check for 'next page'
            );

            // If navigating forward (page > currentPage)
            if (page > currentPage && lastVisible) {
                songsQuery = query(songsQuery, startAfter(lastVisible));
            } 
            
            // Handle Search filtering (simple startsWith logic using index range)
            if (searchTerm.length > 0) {
                 // For search, we must order by the searched field for the range query to work.
                 // Since we cannot rely on the index being created, we simplify to a client-side friendly query 
                 // (only one filter/order) or rely on the range query if sorting is customName.
                 
                 // Since the app needs to function without custom indexes, we will fetch and filter client-side
                 // for search terms, but only apply the range query for the first letter for Firestore efficiency.
                 
                 songsQuery = query(
                    getPrivateCollectionRef('tws-songs'),
                    where('customName', '>=', searchTerm),
                    where('customName', '<=', searchTerm + '\uf8ff'),
                    orderBy('customName', 'asc'), // Must order by customName
                    limit(SONGS_PER_PAGE + 1)
                );
                // Note: Pagination tokens (lastVisible) would be complex here, so we reset to page 1 for search results.
                if (page > 1) {
                    page = 1; 
                }
            }


            // Use onSnapshot for real-time updates on the current page/filter
            songsUnsubscribe = onSnapshot(songsQuery, (snapshot) => {
                const songs = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));
                
                // Determine if there is a next page
                const hasMore = songs.length > SONGS_PER_PAGE;
                
                // Slice the results to the page limit
                const songsToShow = hasMore ? songs.slice(0, SONGS_PER_PAGE) : songs;

                // Update pagination tokens only if we show results
                if (songsToShow.length > 0) {
                    lastVisible = snapshot.docs[songsToShow.length - 1]; // Token for next page
                    firstVisible = snapshot.docs[0]; // Token for current page start
                } else {
                    lastVisible = null;
                    firstVisible = null;
                }
                
                // Update current page number and controls
                currentPage = page;
                updatePaginationControls(songsToShow.length, hasMore);

                renderSongs(songsToShow);

            }, (error) => {
                console.error("Error fetching songs:", error);
                songList.innerHTML = `<p class="text-red-400">Error loading music: ${error.message}</p>`;
            });
        };

        // Escuchadores para la búsqueda y el filtro/paginación
        searchInput.addEventListener('input', () => {
            currentPage = 1;
            lastVisible = null; // Reset pagination on search
            setupSongsListener(1);
        });

        sortFilter.addEventListener('change', () => {
            currentPage = 1;
            lastVisible = null; // Reset pagination on sort change
            setupSongsListener(1);
        });
        
        // Paginación
        prevPageBtn.addEventListener('click', () => {
            // Given the complexity of backward pagination with Firestore cursors, 
            // we will simply alert the user that it's not supported in this simple version.
            window.alertUser("Navigation Locked", "Backward navigation is not supported with simple Firestore cursors. Please use sorting/searching.", 'var(--color-primary)');
        });

        nextPageBtn.addEventListener('click', () => {
            if (!nextPageBtn.disabled) {
                setupSongsListener(currentPage + 1);
            }
        });


        // ---------------------------------------------------------------------
        // V. CORE INITIALIZATION (Inicialización Central)
        // ---------------------------------------------------------------------

        /**
         * Inicializa Firebase y la autenticación (solo se llama si el acceso es concedido).
         */
        const initApp = async () => {
            try {
                const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
                
                if (Object.keys(firebaseConfig).length === 0 || !firebaseConfig.apiKey) {
                    throw new Error("Missing or invalid Firebase configuration.");
                }

                // Inicializar servicios
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                storage = getStorage(app);

                // Autenticación con token o anónima
                const authPromise = typeof __initial_auth_token !== 'undefined'
                    ? signInWithCustomToken(auth, __initial_auth_token)
                    : signInAnonymously(auth);
                await authPromise;

                // Configurar el listener de cambio de estado de autenticación
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        // Usamos el UID aquí para configurar rutas de Firestore
                        userId = user.uid;
                        loginStatusMessage.classList.add('hidden'); 

                        // Habilitar controles
                        fileInput.disabled = false;
                        uploadButton.disabled = false;
                        uploadButton.innerHTML = `<i data-lucide="upload" class="w-5 h-5 mr-2"></i> Upload`;
                        
                        // Si la pestaña de lista está activa, cargar los datos
                        if (!document.getElementById('tab-list').classList.contains('hidden')) {
                            setupSongsListener(); 
                        }
                        lucide.createIcons();

                    } else {
                        userId = null;
                        loginStatusMessage.textContent = "Authentication Failed. Please check console for details.";
                        loginStatusMessage.className = 'text-center text-sm text-red-400 py-2 rounded-md font-medium';
                        loginStatusMessage.classList.remove('hidden'); 
                        uploadButton.disabled = true;
                        uploadButton.innerHTML = `<i data-lucide="alert-triangle" class="w-5 h-5 mr-2"></i> Authentication Required`;
                        lucide.createIcons();
                    }
                });

            } catch (error) {
                console.error("Firebase Initialization/Authentication Error:", error);
                loginStatusMessage.textContent = `FATAL DB ERROR: ${error.code || error.message}`;
                loginStatusMessage.className = 'text-center text-sm text-red-400 py-2 rounded-md font-medium';
                loginStatusMessage.classList.remove('hidden'); 
                uploadButton.disabled = true;
                uploadButton.innerHTML = `<i data-lucide="alert-triangle" class="w-5 h-5 mr-2"></i> DB Error`;
                lucide.createIcons();
            }
        };

        // --- Event Listeners de la UI ---
        
        // 1. Alternativa de click en el marco para abrir el selector de archivo
        fileSelectionFrame.addEventListener('click', () => {
            if (!fileInput.disabled) {
                fileInput.click();
            }
        });

        // 2. Actualizar el botón y el marco al seleccionar un archivo
        fileInput.addEventListener('change', () => {
            const file = fileInput.files[0];
            const customName = customNameInput.value.trim();

            if (file) {
                selectedFileNameDisplay.innerHTML = `Selected File: <span class="font-semibold text-white">${file.name}</span>`;
                fileSelectionFrame.classList.add('border-blue-500');

                if (customName.length > 0) {
                    uploadButton.disabled = false;
                    uploadButton.innerHTML = `<i data-lucide="upload" class="w-5 h-5 mr-2"></i> Upload`;
                } else {
                    uploadButton.disabled = true;
                    uploadButton.innerHTML = `<i data-lucide="upload-cloud" class="w-5 h-5 mr-2"></i> Enter Name & Upload`;
                }

            } else {
                selectedFileNameDisplay.textContent = "No file selected. Click to select a file.";
                fileSelectionFrame.classList.remove('border-blue-500');
                uploadButton.disabled = false;
                uploadButton.innerHTML = `<i data-lucide="upload" class="w-5 h-5 mr-2"></i> Upload`;
            }
            lucide.createIcons();
        });

        // 3. Listener del campo de nombre personalizado 
        customNameInput.addEventListener('input', () => {
            const fileSelected = fileInput.files.length > 0;
            const customName = customNameInput.value.trim();

            if (fileSelected && customName.length > 0) {
                uploadButton.disabled = false;
                uploadButton.innerHTML = `<i data-lucide="upload" class="w-5 h-5 mr-2"></i> Upload`;
            } else {
                if (fileSelected) {
                    uploadButton.disabled = true;
                    uploadButton.innerHTML = `<i data-lucide="upload-cloud" class="w-5 h-5 mr-2"></i> Enter Name & Upload`;
                } else {
                    // Si no hay archivo, el botón debería funcionar como selector (click en fileInput)
                    uploadButton.disabled = false; 
                    uploadButton.innerHTML = `<i data-lucide="upload" class="w-5 h-5 mr-2"></i> Upload`;
                }
            }
            lucide.createIcons();
        });

        // 4. Controlador del botón único (Seleccionar o Subir)
        uploadButton.addEventListener('click', () => {
            const file = fileInput.files[0];
            const customName = customNameInput.value;

            if (!file) {
                fileInput.click();
            } else if (file && customName) {
                uploadSong(file, customName);
            } else {
                window.alertUser('Input Error', 'Please enter a custom name before uploading.', 'var(--color-danger)');
            }
        });
        
        // Manejar el intento de acceso
        accessButton.addEventListener('click', handleAccessAttempt);
        accessPassword.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleAccessAttempt();
            }
        });


        // Función para copiar al portapapeles (accesible globalmente)
        window.copyToClipboard = (text) => {
            const tempInput = document.createElement('textarea');
            tempInput.value = text;
            document.body.appendChild(tempInput);
            tempInput.select();
            document.execCommand('copy');
            document.body.removeChild(tempInput);
            window.alertUser('Copied', 'Link copied to clipboard!', 'var(--color-secondary)');
        };

        // --- INICIO DE LA APLICACIÓN ---
        window.onload = () => {
            lucide.createIcons(); // Renderizar iconos iniciales
            
            if (checkAccess()) {
                grantAccess();
            } else {
                accessGate.classList.remove('hidden');
            }
        };
    </script>
</body>
</html>
